from grammar.grammar_nodes import *

FUNCTION = Literal("function")
PROCEDURE = Literal("procedure")
OPEN_BRACKET = Literal("(")
CLOSE_BRACKET = Literal(")")
OPEN_CURLY_BRACKET = Literal("{")
CLOSE_CURLY_BRACKET = Literal("}")
COMMA = Literal(",")
SEMICOLON = Literal(";")
RETURN = Literal("return")
ASSIGN = Literal("=")
IF = Literal("if")
ELSE = Literal("else")
PLUS = Literal("+")
MULT = Literal("*")
OR = Literal("||")
AND = Literal("&&")
NOT = Literal("!")
LESS = Literal("<")
GREATER = Literal(">")
LEQ = Literal("<=")
GEQ = Literal(">=")
EQUALS = Literal("==")

IDENT = NamedTerminal("IDENT")
INTEGER = NamedTerminal("INTEGER")

script = NonTerminal("script")
subroutineDecl = NonTerminal("subroutineDecl")
statement = NonTerminal("statement")
subroutineHeading = NonTerminal("subroutineHeading")
functionHeading = NonTerminal("functionHeading")
procedureHeading = NonTerminal("procedureHeading")
paramList = NonTerminal("paramList")
block = NonTerminal("block")
returnStatement = NonTerminal("returnStatement")
assignStatement = NonTerminal("assignStatement")
callStatement = NonTerminal("callStatement")
ifStatement = NonTerminal("ifStatement")
intExpr = NonTerminal("intExpr")
subroutineCall = NonTerminal("subroutineCall")
argumentList = NonTerminal("argumentList")
boolExpr = NonTerminal("boolExpr")
intTerm = NonTerminal("intTerm")
intFactor = NonTerminal("intFactor")
boolTerm = NonTerminal("boolTerm")
boolFactor = NonTerminal("boolFactor")
comparison = NonTerminal("comparison")

script.rule = Star(Or([subroutineDecl, statement]))
subroutineDecl.rule = Concat([subroutineHeading, block])
subroutineHeading.rule = Or([functionHeading, procedureHeading])
functionHeading.rule = Concat([FUNCTION, IDENT, paramList])
procedureHeading.rule = Concat([PROCEDURE, IDENT, paramList])
block.rule = Concat([OPEN_CURLY_BRACKET, Star(statement), CLOSE_CURLY_BRACKET])
paramList.rule = Concat([OPEN_BRACKET, Question(Concat([IDENT, Star(Concat([COMMA, IDENT]))])), CLOSE_BRACKET])
argumentList.rule = Concat([OPEN_BRACKET, Question(Concat([intExpr, Star(Concat([COMMA, intExpr]))])), CLOSE_BRACKET])
statement.rule = Or([returnStatement, assignStatement, callStatement, ifStatement])
returnStatement.rule = Concat([RETURN, Question(intExpr), SEMICOLON])
assignStatement.rule = Concat([IDENT, ASSIGN, intExpr, SEMICOLON])
callStatement.rule = Concat([subroutineCall, SEMICOLON])
ifStatement.rule = Concat([IF, boolExpr, block, Question(Concat([ELSE, block]))])
subroutineCall.rule = Concat([IDENT, argumentList])
intExpr.rule = Concat([intTerm, Star(Concat([PLUS, intTerm]))])
intTerm.rule = Concat([intFactor, Star(Concat([MULT, intFactor]))])
intFactor.rule = Or([INTEGER, Concat([OPEN_BRACKET, intExpr, CLOSE_BRACKET]), subroutineCall, IDENT])
boolExpr.rule = Concat([boolTerm, Star(Concat([OR, boolTerm]))])
boolTerm.rule = Concat([boolFactor, Star(Concat([AND, boolFactor]))])
boolFactor.rule = Concat([Question(NOT), Or([comparison, Concat([OPEN_BRACKET, boolExpr, CLOSE_BRACKET])])])
comparison.rule = Concat([intExpr, Or([LESS, LEQ, EQUALS, GEQ, GREATER]), intExpr])
